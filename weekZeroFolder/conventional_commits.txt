ğŸ“ What Conventional Commits Means
Structure

A commit message looks like:

<type>[optional scope]: <short description>

[optional body]

[optional footer(s)]


type â†’ what kind of change it is

scope (optional) â†’ part of the codebase it touches

description â†’ short summary

body (optional) â†’ details, reasoning

footer(s) (optional) â†’ extra notes, e.g. breaking changes or references

Types Youâ€™ll Use Most

feat: â†’ adds a new feature (like a new function, API endpoint, or GUI button)

fix: â†’ fixes a bug

Other common ones:

docs: documentation only

style: code style (formatting, spacing, etc., no logic change)

refactor: code change that isnâ€™t a bug fix or new feature (cleanup, reorganizing)

test: adding or updating tests

chore: maintenance, config, dependencies

Breaking Changes

Add ! or a footer to mark a breaking change:

feat!: remove old login API
BREAKING CHANGE: login() function is no longer supported


Tells tools/users: this will break existing code that depends on the old version.

Why Itâ€™s Useful

Automated changelogs â†’ tools can auto-generate release notes from your commits.

Versioning â†’ ties to SemVer
:

fix: â†’ patch release (1.0.1 â†’ 1.0.2)

feat: â†’ minor release (1.0.0 â†’ 1.1.0)

BREAKING CHANGE: â†’ major release (1.x â†’ 2.0.0)

Clear communication â†’ teammates instantly know what changed.

Consistency â†’ no random commit messages like â€œstuffâ€ or â€œfinal changes.â€

Examples
feat(lang): add Polish language
fix(auth): handle null token correctly
docs: update README with setup instructions
refactor(parser): simplify error handling
chore: update dependencies


ğŸ‘‰ In short:
Conventional Commits = a rulebook for commit messages so theyâ€™re consistent, machine-readable, and meaningful